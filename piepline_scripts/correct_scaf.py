#!/usr/bin/env python
import os
import sys
from collections import defaultdict
from Bio import SeqIO
import argparse
import shutil
import subprocess
import gzip
from itertools import islice  

parser = argparse.ArgumentParser(description='Cut off the contig with variable coverage at breakpoint. ')

parser.add_argument("-ld", '--long_depth', required=True, help='long read depth')
parser.add_argument("-sd", '--short_depth', required=True, help='short read depth')
parser.add_argument("-g", '--gff', required=False, help='gff file generated by prodigal')
parser.add_argument("-a", '--fasta', required=True, help='fasta file of assembly to be corrected')
parser.add_argument("-o", '--outdir', required=True, help='output directory')
parser.add_argument("-p", '--prefix', required=False, default = "tmp", help='output file prefix')
parser.add_argument("-f", '--force' , default= False ,action = 'store_true', help='overwriting the existing files')
parser.add_argument("-l", '--lower' , default= 0.2 , type = float, help='lower limit of coverage (default 0.2)')
parser.add_argument("-u", '--upper' , default= 3 , type = float, help='lower limit of coverage (default 3)')
parser.add_argument("-i", '--interval' , default= 50000 , type = int, help='interval of slide windows (default 50000)')
parser.add_argument("-m", '--minlen' , default= 600 , type = int, help='minimum length of the contig to be corrected (KB) (default 600)')
parser.add_argument("-pl", '--pass_list', help='circular scaffold list used for skip correction')


args = parser.parse_args()

# def read_file(file_path):
    # if file_path.endswith("gz"):
        # opened_file = gzip.open(file_path, "rb")
    # else:
        # opened_file = open(file_path, "rb")
    # return(opened_file)

## set variable
long_depth = args.long_depth
short_depth = args.short_depth
# gff = args.gff
raw_fasta = args.fasta
outdir = args.outdir
lower = args.lower
upper = args.upper
interval = args.interval
minlen = args.minlen
prefix = args.prefix
pass_file = args.pass_list

if not os.path.exists(outdir):
    os.makedirs(outdir)
else:
    if args.force == True:
        shutil.rmtree(outdir, ignore_errors=True)
        os.makedirs(outdir)
    else:
        print("Outdir already exist, please rename it or use --force")
        sys.exit()


table_tmp = open(outdir + "/table.tmp", 'w')
table_tmp_all = open(outdir + "/table.tmp_all", 'w')

## load the circular contigs list 
if pass_file:
    if os.path.exists(pass_file):
        pass_dict = {}
        for line in open(pass_file):
                pass_dict[line.strip()] = "a"
    else:
        print("The circular list not exists")
        sys.exit()

counter = 0
n="x"
table_list = []

if not args.gff:
    if subprocess.call(["which", "prodigal"]) == 1:
        logging.error('Prodigal is not in your PATH, please check it.')
        sys.exit()
    ## run prodigal
    prodigal_dir = outdir + "/" + "prodigal_out"
    os.makedirs(prodigal_dir)
    prodigal_faa = prodigal_dir + "/" + prefix + ".faa"
    prodigal_gff = prodigal_dir + "/" + prefix + ".gff"
    prodigal_logic = subprocess.call( ["prodigal", "-q", "-i", raw_fasta, "-f", "gff", "-a", prodigal_faa, "-o", prodigal_gff ])
    if prodigal_logic == 1:
        logging.error('Prodigal failed.')
        sys.exit()
    gff_file = prodigal_gff
else:
    gff_file = args.gff

## merge depth tables
tmp_dir = outdir + "/tmp"
os.makedirs(tmp_dir)
long_depth_modified = tmp_dir + "/long_depth"  + ".f"
short_depth_modified = tmp_dir + "/short_depth" + ".f"
merged_table = tmp_dir + "/" + "merged_table"

merged_cmd1 = "less " + long_depth + ''' | perl -lane 'print "@F[0]_@F[1]\\t$_"'  > ''' + long_depth_modified

merged_cmd2 = "less " + short_depth + ''' | perl -lane 'print "@F[0]_@F[1]\\t$_"' > ''' + short_depth_modified

merged_cmd3 = "csvtk join -t -T -H -k " + short_depth_modified + " " + long_depth_modified + " | cut -f 1-5,9 > " + merged_table

run1 = subprocess.call(merged_cmd1, shell=True)
run2 = subprocess.call(merged_cmd2, shell=True)
run3 = subprocess.call(merged_cmd3, shell=True)

### utilized functions
def sliding_window(seq_list):
    out_list = []
    half_interval = 25
    end = len(seq_list)
    unit_size = int(seq_list[0][3])
    window_size = int(half_interval/unit_size)
    for i in range(0, end):
        HC = 0  # the number of regions depth higher than the average depth.
        LC = 0  # the number of regions depth lower than the average depth.
        pre_depth = 0.0
        aft_depth = 0.0
        pre_long_depth = 0.0
        aft_long_depth = 0.0
        join_line = "\t".join(seq_list[i])
        if i < half_interval or i > end - half_interval :
            out_line = [join_line, "NA", "NA", "NA"]
            out_join = "\t".join(out_line)
            out_list.append(out_join)
            continue
        else:
            slide_end = i + window_size

            if slide_end >= end:
                slide_end = end
            window = seq_list[i-half_interval : i+half_interval]
            for j in range(0, len(window)):
                try:
                    region_depth = float(window[j][4])
                except ValueError:
                    region_depth = 0.0
                try:
                    long_region_depth = float(window[j][5])
                except ValueError:
                    long_region_depth = 0.0
                if j < half_interval:
                    pre_depth += region_depth
                    pre_long_depth += long_region_depth
                else:
                    aft_depth += region_depth
                    aft_long_depth += long_region_depth
        try:
            ratio = float(pre_depth)/float(aft_depth)
        except ZeroDivisionError:
            ratio = 0
        long_ratio =  float(pre_long_depth)/float(aft_long_depth)
        out_line = [join_line, str(ratio), str(pre_depth), str(aft_depth), str(long_ratio), str(pre_long_depth), str(aft_long_depth) ] 
        out_join = "\t".join(out_line)
        out_list.append(out_join)
    return(out_list)

def lookup_breakpoint(contigs_out):
    return_list = []
    for i in range(0, len(contigs_out)):
        isp = contigs_out[i].split("\t")
        if i == 0 or i >= len(contigs_out)-1:
            return_list.append(isp) 
            continue
        pre_sp = contigs_out[i-1].split("\t")
        aft_sp = contigs_out[i+1].split("\t")
        try :
            short_ratio = float(isp[6])
            long_ratio =  float(isp[9])
            depth =  float(isp[4])
            pre_ratio = float(pre_sp[6])
            aft_ratio = float(aft_sp[6])
            pre_depth =  float(pre_sp[4])
            aft_depth = float(aft_sp[4])
            pre_ratio_long = float(pre_sp[9])
            aft_ratio_long = float(aft_sp[9])
            pre_depth_long =  float(pre_sp[5])
            aft_depth_long = float(aft_sp[5])
        except ValueError:
            return_list.append(isp) 
            continue
        if short_ratio < lower and \
            (long_ratio < lower and long_ratio < pre_ratio_long and long_ratio < aft_ratio_long and pre_depth_long < aft_depth_long):
            if short_ratio < lower and short_ratio < pre_ratio and short_ratio < aft_ratio and 2*pre_depth < aft_depth :  
                isp.append( "breakpoint")
                return_list.append(isp)
            else:
                return_list.append(isp)
        elif short_ratio > upper  and (long_ratio > upper and long_ratio > pre_ratio_long and long_ratio > aft_ratio_long):
        # elif short_ratio > upper  or long_ratio > upper :
            if short_ratio > pre_ratio and short_ratio > aft_ratio and pre_depth > 2*aft_depth:
                isp.append( "breakpoint")
                return_list.append(isp)
            else:
                return_list.append(isp)
        else:
            return_list.append(isp)
    return(return_list)


def cut_sequence(seq, point_list):
    point_list = list(map(lambda x:int(x), point_list))
    cut_seq_out_dic = {}
    new_point_list = [1] + point_list + [len(seq.seq) + 1]
    seq_str = str(seq.seq)
    for i in range(0, len(new_point_list)-1 ):
        cut_seq_name = seq.id + "_" + str(i+1) + "_" + str(new_point_list[i]) + "_" + str(new_point_list[i+1]-1)
        cut_seq_seq = seq_str[new_point_list[i] - 1 : new_point_list[i+1] - 1]
        cut_seq_out_dic[cut_seq_name] = cut_seq_seq
    return(cut_seq_out_dic)


## load depth table
for line in open(merged_table):
    line_s = line.strip().split("\t")
    if line_s[1] != n:
        table_list.append([line_s])
        n = line_s[1]
    else:
        table_list[-1].append(line_s)

final_list = []
for item in table_list:
    if len(item) < minlen:
        continue
    contigs_out = sliding_window(item)
    final_list.append(lookup_breakpoint(contigs_out))


gene_dict = defaultdict(list)
breakpoint_list = []
counter2 = 0

for line in open(gff_file):
    if line.startswith('#'):
        continue
    line_sp = line.split()
    gene_dict[line_sp[0]].append(line_sp[3:5])

breakpoint_num = 0
for i in final_list:
    for j in i:
        table_tmp_all.write("\t".join(j) + "\n")
        # pre_gene_start = 99990000000
        # pre_gene_end = 9999999999999
        cut_point = "NA"
        if 'breakpoint' in j:
            breakpoint_num += 1
            for k in gene_dict[j[1]]:
                gene_start, gene_end = map(lambda x:int(x), k[0:2])
                seq_start, seq_end = map(lambda x:int(x), j[2:4])
                # print gene_start, gene_end, seq_start, seq_end
                gene_len = gene_end - gene_start + 1
                if gene_start < seq_start and gene_end > seq_start:
                    cov = float((gene_end - seq_start))/float(gene_len)
                    if cov > 0.5:
                        cut_point = gene_start
                    else:
                        cut_point = gene_end + 1
                # elif pre_gene_start < seq_start and gene_start > seq_start:
                #     cut_point = seq_start
                else:
                    # print ("aaaa")
                    continue
                # pre_gene_start = gene_start
                # pre_gene_end = gene_end
            if cut_point == "NA":
                print (j)
                cut_point = j[2]
            breakpoint_list.append(j+[str(cut_point)]) 

if breakpoint_num == 0:
    print ("No divergent coverage sequence.")
    cp_out = outdir + "/corrected.fasta"
    cmd='cp "%s" "%s"' % (raw_fasta, cp_out)
    subprocess.call (cmd, shell=True)
    sys.exit()

breakpoint_list_sort = sorted(breakpoint_list, key = lambda x:[x[1], int(x[2])] )
breakpoint_dict = defaultdict(list)
for i in breakpoint_list_sort:
    table_tmp.write("\t".join(i) + "\n")
    breakpoint_dict[i[1]].append(i[-1])


#less C40.assembly_info.txt | perl -e 'while(<STDIN>){print "@ARGV[0]_$_" }' C40
## write the output
corrected_fasta = open(outdir + "/corrected.fasta", 'w')
corrected_fastq_name = open(outdir + "/corrected_fastq_name", 'w')
## load fasta
for record in SeqIO.parse(raw_fasta, 'fasta'):
    if record.id in breakpoint_dict and record.id not in pass_dict:
        breaked_seq =  cut_sequence(record, breakpoint_dict[record.id])
        for key in breaked_seq:
            corrected_fasta.write( ">"+ key + "\n" + breaked_seq[key] + "\n")
            corrected_fastq_name.write(key + "\n")
    else:
        corrected_fasta.write( ">" + record.id + "\n" + str(record.seq) + "\n")

